use std::vec;


fn main() {

    
    //  ðŸ“Œ Macro "println!" Display the message "Hello, world!"
    
    println!("1 - Hello, world!");

    /*
    ðŸ“Œ Pasar argumentos a la macro entre corchetes "brakes"
    llamar a macro println! con 4 argumentos: a string, a valor, string, a valor
    */
    let text1 = "2 - La primera letra del alfabeto";
    let text2 = "La Ãºltima letra del alfabeto:";
    let sa = (13, false);

    println!("{}: {} y {} {} y \n2 - array pos 0 = {} \n2 - array pos 1 = {}", text1, 'A', text2, 'Z', sa.0, sa.1);
   

    let mut _b_number = 5;
    _b_number += 1;
    println!(
        "4 - Este es el nuevo valor que reemplaza el anterior '5' por ser la misma variable: {}",
        _b_number
    );

//  ðŸ“Œ AquÃ­ los tipos los e implementado yo, despuÃ©s de la variable insertar los ":" y el tipo.

    let _x: u32 = 42; // integer de 32 bits sin signo
    let url: String = String::from("http://desarrollosdigitales.info"); // tipo "String"
    let a_url = "http://desarrollosdigitales.info"; // tipo texto "&str"

    println!("5 - Esto es un String: {}", url);
    println!("6 - Esto es un Texto &str: {}", a_url);

/*  ðŸ“Œ ARRAYS - Un array es una colecciÃ³n de longitud fija de elementos de datos del mismo tipo.
       El tipo de datos para un array es [T;N] siendo T el tipo del elemento, y N la longitud fija 
       conocida en tiempo de compilaciÃ³n. Los elementos individuales se pueden recuperar con el 
       operador [x], siendo x un Ã­ndice de tipo usize (empezando por 0) del elemento que quieras.              
*/
    let nums: [i32;3] = [1,2,3];
    println!("7 - Arrays es una colecciÃ³n con longitud fija de elementos de datos del mismo tipo  {:?}", nums);
    println!("7 - Acceder a la posiciÃ³n 2 de un array nums[1]= {}", nums[1]);





//  ðŸ“Œ ARRAYS - VECTORES | Estructutas de datos

    let mut notas_array: [u32; 5] = [0; 5];  // Array con tamaÃ±o fijo de 5 elementos e inicializadas las 5 posiciones con ceros
    notas_array[0] = 1;
    notas_array[1] = 6;
    println!("7 - Nota 1 = {}\n    Nota 2 = {}\n", notas_array[0], notas_array[1]);

//  ðŸ“Œ VECTORES | Estructutas de datos 

    let mut notas_vec: Vec<i32> = vec!(); // Vector dinÃ¡mico (No fijo) vaciÃ³, integer 32 bits con signo 
    notas_vec.push(1); // escribimos un valor
    notas_vec.push(6); // escribimos un segundo valor
    println!("8 - Nota 1 = {}\n    Nota 2 = {}\n", notas_vec[0], notas_vec[1]);

//  ðŸ“Œ CONSTANTES
    
    const PI:f64 = 3.14159;
     println!("9 - Vamos de paseo, {} {} {}", PI, PI, PI);

//  ðŸ“Œ CONSTANTES y casting ("as")

    const costante: f64 = 3.14;   // constante valor para PI, SCREAMING_SNAKE_CASE para las constantes
    let xa = 42;       // variable con asignaciÃ³n de tipo y valor
    let xa = (xa as f64) + costante; // la palabra reservada "as" es hacer casting "convertir de tipo, 
                                    // y al mismo tiempo estamos haciendo "shadowing" al  redefinir la variable "xa"
    println!("9 - El valor de xa es: {}", xa);

    //  ðŸ“Œ Casting - conversiÃ³n de tipos
    let a = 13u8;
    let b = 7u32;
    let c = a as u32 + b;
    println!("9 - a convertido a u32: {}", c);
    let t = true;
    println!("{}", t as u8);

    /*
    ðŸ“Œ TUPLAS, son como una estructura sin nombre de campos, una especie de array donde 
    cada elemento puede ser de un tipo diferente pero especificado de antemano
    */

    let tupla = (23,"Javier", true);       // Formamos la tupla directamente con valores de tipo (integer, texto, boleano)    
    let (random, z_name, has_beers) = tupla; // Desestructuramos la tupla y obtenemos 3 variables
    // Imprimimos las variables obtenidas
    println!("\n10 - {}", random);
    println!("11 - {}", z_name);
    println!("12 - {}\n", has_beers);

    /*
    ðŸ“Œ EXPRESIONES AVANZADAS con variables "let", expresiÃ³n condicional con "if, else", 
       en Rust si algo no lleva punto y coma se vuelve Y evalÃºa como una expresiÃ³n
    */

    let age: u8 = 15;
    let xx = if age > 17
    {
        "Mayor de edad"
    } else 
    {
        "Menor de edad"
    };
    println!("13 - Eres{}",xx);

//  ðŸ“Œ EXPRESIONES AVANZADAS con variables "let", una operaciÃ³n de "a*b"
    
    let u = 2;
    let _xa = u+age;                // el valor de "u" se suma al de "age"
    println!("14 - Valor de x: {}",_xa);        // imprime la expresiÃ³n avanzada de "x"

    /*
    ðŸ“Œ Rust no deja la memoria al descubierto ni usa GC. Para ello el compilador realiza 
       una tarea de dueÃ±os y prÃ©stamos que veremos a continuaciÃ³n.
       Las REGLAS -> Cada valor en Rust tiene una variable que es su dueÃ±a
                  -> Un valor solo puede tener un dueÃ±o a la vez
                  -> Cuando el dueÃ±o desaparece, el valor lo hace a su vez, de forma automÃ¡tica
    */

//  ðŸ“Œ La trait COPY y CLONE

    /*
       Distinto comportamiento segÃºn el tipo de un valor, la trait Copy (la mayorÃ­a de tipos primitivos), 
       entonces su comportamiento por defecto es de copia, la copia es barata y rÃ¡pida y no influye 
       que existan varias copias de lo mismo.
       Se trata de valores que se almacenan en el stack.
       Clone permite hacer copias de datos mÃ¡s complejos, por ejemplo de un vector
       La primitiva String solo incorpora Clone, crear una copia dela variable darÃ­a error como el ejemplo de abajo

       fn main(){
       let s1 = String::from("Adios - Xavier Cugat");
       let s2 = s1;
       println!("{}",s1); // ERROR hemos movido el valor de s1 a "s2" "s1" ya no es dueÃ±o de ese valor", ya no podemos imprimir s1 
       ERRROR  
       }
    */

    /*
       Este cÃ³digo da error porque el tipo String no implementa Copy. Entonces la lÃ­nea let s2 = s1; 
       lo que ha hecho en realidad ha sido mover el valor. Mover significa que le ha transferido el 
       ser dueÃ±o del valor de la cadena de texto a s2. Por tanto s1 ya no es dueÃ±a del valor y no puede 
       operar con Ã©l. Esto pasa en los tipos que no implementan Copy, que transfieren la propiedad 
       a otra variable. Si queremos hacer una copia real, tendremos que recurrir al clonado. 
    */
    
    /*
    ðŸ“Œ El tipo String implementa Clone asÃ­ que es posible generar otro dato String exactamente igual 
       pero independiente al original.
    */
    
//  ðŸ“Œ Ejemplo de CLONE para un String

    let s1 = String::from("Adios - Xavier Cugat");
    let s2 = s1.clone();
    println!("15 - Hemos clonado \"s2\" desde \"s1\" ahora las dos variable tienen el mismo valor\n     y cada una es propietaria de si misma, -> valor =  {}",s2);

    /*
    ðŸ“Œ IMPLICACIONES - Pasar una variable tal cual a una funciÃ³n si no es del tipo Copy 
       implica que Â¡perdemos el acceso a ese valor!
    */

    /*
         let s1 =  String::from("Bolero - Maurice Ravel");
         f(s1);
         println!("15 - {}",s1);

       Este cÃ³digo da error. Al hacer la llamada a la funciÃ³n f hemos transferido la propiedad 
       del valor de s1 a f. Por ello, cuando intentamos hacer el print no vamos a poder ya que 
       s1 ya no es dueÃ±a de la cadena de texto. 
       Para solucionar estos problemas tenemos los prÃ©stamos.
    */

    /*
    ðŸ“Œ PRESTAMOS (Prestando en Rust) 2 maneras: solo lectura o con escritura
       NORMA: solo una con permisos de escritura pero infinidad con permiso de lectura, nunca las dos a la vez. 
       El prestamo se realiza con el operador "&" que es una "referencia" de lectura al valor
       La variable sigue siendo la dueÃ±a del valor, solo lo ha prestado y entrega una referencia
    */
    
//        -->-->--> // AQUÃ BUSCAR EJEMPLOS de prestasmos referencia de lectura 

    
//  ðŸ“Œ PRESTAMOS (Prestando en Rust) prestasmo en modo escritura, debemos utilizar "&mut"
    
    fn f(s: &mut String) {
        s.push_str(" & Adios - Xavier Cugat");
    }
    let mut s1 = String::from("16 - Bolero - Maurice Ravel");
    f(&mut s1);
    println!("{}",s1);

    /*
    ðŸ“Œ FUNCIONES SIMPLES - Si la funciÃ³n devuelve un valor se debe poner una flecha
       y el tipo del valor de devoluciÃ³n. Para devolver un valor se puede usar return 
       o se puede dejar la Ãºltima lÃ­nea sin punto y coma.
    */

    fn suma(a:i32, b:i32) ->i32 {
        a+b
    }
    let a = 5;
    let b = 42;
    let c= suma(a,b);
    println!("17 - resultado es: {}",c);

//  ðŸ“Œ Rust como tal no admite devolver varios valores a la vez, pero es posible usar tuplas y simularlo.

    fn string_length_and_lines(txt: &String) -> (usize,usize) {
    (txt.len(),txt.lines().count()) // funciÃ³n contar cantidad caracteres
    }
    let ss = String::from("Europe's Skies - Alexander Rybak\nSuper Strut - Deodato\nEl CÃ³ndor Pasa - UÃ±a Ramos");
    // asignamos 3 lineas de tipo Striterminalng a variable "ss"
    let (length,lines) = string_length_and_lines(&ss); // asignamos el valor de la funciÃ³n contar_cantidad_caracteres
    // a variable longitud y lineas
    println!("18 - La lista de canciones tiene una longitud de {} caracteres y {} lÃ­neas",length,lines); // salida por pantalla variables resultados

//  ðŸ“Œ  las funciones son elementos de primer nivel, lo que quiere decir que pueden pasarse por argumentos 
//      entre funciones

    fn ladrar () {
        println!("19 - Guau");
    } // funciÃ³n ladrar
    fn hacer_n_veces(f:fn(),n:i64) {
        for _ in 0..n {
          f();
        } // bucle for in
    }
    hacer_n_veces(ladrar,10); // imprime 10 veces resultado de la funciÃ³n ladrar

//  ðŸ“Œ  Aqui generacidad, poner algo

//  ðŸ“Œ  Aqui CLOSURES

//  ðŸ“Œ  Structs, traits y POO en Rust

//  ðŸ“Œ ESTRUCTURAS son datos agrupados por clave-valor.

    #[derive(Copy,Clone)]
    struct Punto{
    x: i32,
    y: i32
}

    struct Rectangulo{
    origen: Punto,
    ancho: i32,
    alto: i32
}  
    let p = Punto {x: 50, y: 50};
        println!("20 - Punto X: {}",p.x);

//  ðŸ“Œ 

    


      

    










    





    //  ðŸ“Œ   TIPOS BÃSICOS

    // Booleanos - bool para representar verdadero/falso.
    // NÃºmeros enteros sin signo - u8 u32 u64 u128 para representar nÃºmeros enteros positivos.
    // NÃºmeros enteros con signo - i8 i32 i64 i128 para representar nÃºmeros enteros positivos y negativos.
    // NÃºmeros enteros de tamaÃ±o de puntero - usize isize se usan para representar Ã­ndices y tamaÃ±os de elementos en memoria.
    // NÃºmeros en coma flotante - f32 f64.
    // En relaciÃ³n a textos - String y str char.
    // Tuplas - (valor,valor,...) para pasar secuencias fijas de valores en la pila, acceso por indice.
    // Slices - &[T] para referenciar â€œvistasâ€ en secuencias de valores en la memoria.
    



    //  ðŸ“Œ  CARGO Y OTROS

    // cargo new -> crea un directorio de proyecto
    // cargo build -> compila
    // cargo run  -> compila si hay cambios en el proyecto y ejecuta el mismo
    // cargo check -> testea el proyecto
    // cargo run --bin [programa_rust] -> si el proyecto esta en otro directorio
    // cargo build --release -> para compilarlo con optimizaciones
    // cargo edit -> nos ayuda con las dependencias inserta o importa el nombre de un crate (libreria o mÃ³dulo)
    // -> reescribe el archivo Cargo.toml para adicionar de pendencias -> https://github.com/killercup/cargo-edit
    // -> viendo la versiÃ³n que necesitas en crates.io

    // ðŸ“Œ   ESTILOS DEL CÃ“DIGO

    // Es una convenciÃ³n en Rust utilizar snake_case para: variables, funciones y archivos
    // SCREAMING_SNAKE_CASE -> para constantes y estÃ¡ticas, en mayusculas y guiones bajos
    // PascalCas -> se utiliza para tipos, rasgos y enums
    // GuiÃ³n bajo (underscores) como sufijo de las variables para que no salga la advierta de "variable no utilizada


    














}
